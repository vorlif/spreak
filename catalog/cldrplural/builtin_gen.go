// This file is generated by cldrplural/generator/generate.sh; DO NOT EDIT
package cldrplural

import (
	"math"
	"slices"
)

func forLanguage(lang string) *RuleSet {
	switch lang {
	case "bm", "bo", "dz", "hnj", "id", "ig", "ii", "ja", "jbo", "jv", "jw", "kde", "kea", "km", "ko", "lkt", "lo", "ms", "my", "nqo", "osa", "sah", "ses", "sg", "su", "th", "to", "tpi", "und", "vi", "wo", "yo", "yue", "zh":
		return newRuleSetBmBoDzHnjIdIgIiJaJboJvJwKdeKeaKmKoLktLoMsMyNqoOsaSahSesSgSuThToTpiUndViWoYoYueZh()
	case "af", "an", "asa", "az", "bal", "bem", "bez", "bg", "brx", "ce", "cgg", "chr", "ckb", "dv", "ee", "el", "eo", "eu", "fo", "fur", "gsw", "ha", "haw", "hu", "jgo", "jmc", "ka", "kaj", "kcg", "kk", "kkj", "kl", "ks", "ksb", "ku", "ky", "lb", "lg", "mas", "mgo", "ml", "mn", "mr", "nah", "nb", "nd", "ne", "nn", "nnh", "no", "nr", "ny", "nyn", "om", "or", "os", "pap", "ps", "rm", "rof", "rwk", "saq", "sd", "sdh", "seh", "sn", "so", "sq", "ss", "ssy", "st", "syr", "ta", "te", "teo", "tig", "tk", "tn", "tr", "ts", "ug", "uz", "ve", "vo", "vun", "wae", "xh", "xog":
		return newRuleSetAfAnAsaAzBalBemBezBgBrxCeCggChrCkbDvEeElEoEuFoFurGswHaHawHuJgoJmcKaKajKcgKkKkjKlKsKsbKuKyLbLgMasMgoMlMnMrNahNbNdNeNnNnhNoNrNyNynOmOrOsPapPsRmRofRwkSaqSdSdhSehSnSoSqSsSsyStSyrTaTeTeoTigTkTnTrTsUgUzVeVoVunWaeXhXog()
	case "ak", "bho", "guw", "ln", "mg", "nso", "pa", "ti", "wa":
		return newRuleSetAkBhoGuwLnMgNsoPaTiWa()
	case "am", "as", "bn", "doi", "fa", "gu", "hi", "kn", "pcm", "zu":
		return newRuleSetAmAsBnDoiFaGuHiKnPcmZu()
	case "ast", "de", "en", "et", "fi", "fy", "gl", "ia", "io", "lij", "nl", "sc", "scn", "sv", "sw", "ur", "yi":
		return newRuleSetAstDeEnEtFiFyGlIaIoLijNlScScnSvSwUrYi()
	case "ceb", "fil", "tl":
		return newRuleSetCebFilTl()
	case "da":
		return newRuleSetDa()
	case "ff", "hy", "kab":
		return newRuleSetFfHyKab()
	case "is":
		return newRuleSetIs()
	case "mk":
		return newRuleSetMk()
	case "si":
		return newRuleSetSi()
	case "tzm":
		return newRuleSetTzm()
	case "blo":
		return newRuleSetBlo()
	case "bs", "hr", "sh", "sr", "sr-Latn":
		return newRuleSetBsHrShSr()
	case "ca", "it", "pt-PT", "vec":
		return newRuleSetCaItPt_PTVec()
	case "es":
		return newRuleSetEs()
	case "fr":
		return newRuleSetFr()
	case "he":
		return newRuleSetHe()
	case "iu", "naq", "sat", "se", "sma", "smi", "smj", "smn", "sms":
		return newRuleSetIuNaqSatSeSmaSmiSmjSmnSms()
	case "ksh":
		return newRuleSetKsh()
	case "lag":
		return newRuleSetLag()
	case "lv", "prg":
		return newRuleSetLvPrg()
	case "mo", "ro", "ro-MD":
		return newRuleSetMoRo()
	case "pt":
		return newRuleSetPt()
	case "shi":
		return newRuleSetShi()
	case "be":
		return newRuleSetBe()
	case "cs", "sk":
		return newRuleSetCsSk()
	case "dsb", "hsb":
		return newRuleSetDsbHsb()
	case "gd":
		return newRuleSetGd()
	case "lt":
		return newRuleSetLt()
	case "pl":
		return newRuleSetPl()
	case "ru", "uk":
		return newRuleSetRuUk()
	case "sl":
		return newRuleSetSl()
	case "br":
		return newRuleSetBr()
	case "ga":
		return newRuleSetGa()
	case "gv":
		return newRuleSetGv()
	case "mt":
		return newRuleSetMt()
	case "ar", "ars":
		return newRuleSetArArs()
	case "cy":
		return newRuleSetCy()
	case "kw":
		return newRuleSetKw()
	default:
		return nil
	}
}

// [bm bo dz hnj id ig ii ja jbo jv jw kde kea km ko lkt lo ms my nqo osa sah ses sg su th to tpi und vi wo yo yue zh]
func newRuleSetBmBoDzHnjIdIgIiJaJboJvJwKdeKeaKmKoLktLoMsMyNqoOsaSahSesSgSuThToTpiUndViWoYoYueZh() *RuleSet {
	return &RuleSet{
		Categories: []Category{Other},
		FormFunc: func(ops *Operands) Category {

			return Other
		},
	}
}

// [af an asa az bal bem bez bg brx ce cgg chr ckb dv ee el eo eu fo fur gsw ha haw hu jgo jmc ka kaj kcg kk kkj kl ks ksb ku ky lb lg mas mgo ml mn mr nah nb nd ne nn nnh no nr ny nyn om or os pap ps rm rof rwk saq sd sdh seh sn so sq ss ssy st syr ta te teo tig tk tn tr ts ug uz ve vo vun wae xh xog]
func newRuleSetAfAnAsaAzBalBemBezBgBrxCeCggChrCkbDvEeElEoEuFoFurGswHaHawHuJgoJmcKaKajKcgKkKkjKlKsKsbKuKyLbLgMasMgoMlMnMrNahNbNdNeNnNnhNoNrNyNynOmOrOsPapPsRmRofRwkSaqSdSdhSehSnSoSqSsSsyStSyrTaTeTeoTigTkTnTrTsUgUzVeVoVunWaeXhXog() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 1
			if ops.N == 1 {
				return One
			}

			return Other
		},
	}
}

// [ak bho guw ln mg nso pa ti wa]
func newRuleSetAkBhoGuwLnMgNsoPaTiWa() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0..1
			if isFloatInRange(ops.N, 0, 1) {
				return One
			}

			return Other
		},
	}
}

// [am as bn doi fa gu hi kn pcm zu]
func newRuleSetAmAsBnDoiFaGuHiKnPcmZu() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 0 or n = 1
			if ops.I == 0 || ops.N == 1 {
				return One
			}

			return Other
		},
	}
}

// [ast de en et fi fy gl ia io lij nl sc scn sv sw ur yi]
func newRuleSetAstDeEnEtFiFyGlIaIoLijNlScScnSvSwUrYi() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 1 and v = 0
			if ops.I == 1 && ops.V == 0 {
				return One
			}

			return Other
		},
	}
}

// [ceb fil tl]
func newRuleSetCebFilTl() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// v = 0 and i = 1,2,3 or v = 0 and i % 10 != 4,6,9 or v != 0 and f % 10 != 4,6,9
			if ops.V == 0 && slices.Contains([]int64{1, 2, 3}, ops.I) || ops.V == 0 && !slices.Contains([]int64{4, 6, 9}, ops.I%10) || ops.V != 0 && !slices.Contains([]int64{4, 6, 9}, ops.F%10) {
				return One
			}

			return Other
		},
	}
}

// [da]
func newRuleSetDa() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 1 or t != 0 and i = 0,1
			if ops.N == 1 || ops.T != 0 && slices.Contains([]int64{0, 1}, ops.I) {
				return One
			}

			return Other
		},
	}
}

// [ff hy kab]
func newRuleSetFfHyKab() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 0,1
			if slices.Contains([]int64{0, 1}, ops.I) {
				return One
			}

			return Other
		},
	}
}

// [is]
func newRuleSetIs() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// t = 0 and i % 10 = 1 and i % 100 != 11 or t % 10 = 1 and t % 100 != 11
			if ops.T == 0 && ops.I%10 == 1 && ops.I%100 != 11 || ops.T%10 == 1 && ops.T%100 != 11 {
				return One
			}

			return Other
		},
	}
}

// [mk]
func newRuleSetMk() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11
			if ops.V == 0 && ops.I%10 == 1 && ops.I%100 != 11 || ops.F%10 == 1 && ops.F%100 != 11 {
				return One
			}

			return Other
		},
	}
}

// [si]
func newRuleSetSi() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0,1 or i = 0 and f = 1
			if isFloatOneOf(ops.N, 0, 1) || ops.I == 0 && ops.F == 1 {
				return One
			}

			return Other
		},
	}
}

// [tzm]
func newRuleSetTzm() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0..1 or n = 11..99
			if isFloatInRange(ops.N, 0, 1) || isFloatInRange(ops.N, 11, 99) {
				return One
			}

			return Other
		},
	}
}

// [blo]
func newRuleSetBlo() *RuleSet {
	return &RuleSet{
		Categories: []Category{Zero, One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0
			if ops.N == 0 {
				return Zero
			}

			// n = 1
			if ops.N == 1 {
				return One
			}

			return Other
		},
	}
}

// [bs hr sh sr]
func newRuleSetBsHrShSr() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Other},
		FormFunc: func(ops *Operands) Category {
			// v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11
			if ops.V == 0 && ops.I%10 == 1 && ops.I%100 != 11 || ops.F%10 == 1 && ops.F%100 != 11 {
				return One
			}

			// v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14
			if ops.V == 0 && (ops.I%10 >= 2 && ops.I%10 <= 4) && !(ops.I%100 >= 12 && ops.I%100 <= 14) || (ops.F%10 >= 2 && ops.F%10 <= 4) && !(ops.F%100 >= 12 && ops.F%100 <= 14) {
				return Few
			}

			return Other
		},
	}
}

// [ca it pt-PT vec]
func newRuleSetCaItPt_PTVec() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 1 and v = 0
			if ops.I == 1 && ops.V == 0 {
				return One
			}

			// e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5
			if ops.C == 0 && ops.I != 0 && ops.I%1000000 == 0 && ops.V == 0 || !(ops.C >= 0 && ops.C <= 5) {
				return Many
			}

			return Other
		},
	}
}

// [es]
func newRuleSetEs() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 1
			if ops.N == 1 {
				return One
			}

			// e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5
			if ops.C == 0 && ops.I != 0 && ops.I%1000000 == 0 && ops.V == 0 || !(ops.C >= 0 && ops.C <= 5) {
				return Many
			}

			return Other
		},
	}
}

// [fr]
func newRuleSetFr() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 0,1
			if slices.Contains([]int64{0, 1}, ops.I) {
				return One
			}

			// e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5
			if ops.C == 0 && ops.I != 0 && ops.I%1000000 == 0 && ops.V == 0 || !(ops.C >= 0 && ops.C <= 5) {
				return Many
			}

			return Other
		},
	}
}

// [he]
func newRuleSetHe() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 1 and v = 0 or i = 0 and v != 0
			if ops.I == 1 && ops.V == 0 || ops.I == 0 && ops.V != 0 {
				return One
			}

			// i = 2 and v = 0
			if ops.I == 2 && ops.V == 0 {
				return Two
			}

			return Other
		},
	}
}

// [iu naq sat se sma smi smj smn sms]
func newRuleSetIuNaqSatSeSmaSmiSmjSmnSms() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 1
			if ops.N == 1 {
				return One
			}

			// n = 2
			if ops.N == 2 {
				return Two
			}

			return Other
		},
	}
}

// [ksh]
func newRuleSetKsh() *RuleSet {
	return &RuleSet{
		Categories: []Category{Zero, One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0
			if ops.N == 0 {
				return Zero
			}

			// n = 1
			if ops.N == 1 {
				return One
			}

			return Other
		},
	}
}

// [lag]
func newRuleSetLag() *RuleSet {
	return &RuleSet{
		Categories: []Category{Zero, One, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0
			if ops.N == 0 {
				return Zero
			}

			// i = 0,1 and n != 0
			if slices.Contains([]int64{0, 1}, ops.I) && ops.N != 0 {
				return One
			}

			return Other
		},
	}
}

// [lv prg]
func newRuleSetLvPrg() *RuleSet {
	return &RuleSet{
		Categories: []Category{Zero, One, Other},
		FormFunc: func(ops *Operands) Category {
			// n % 10 = 0 or n % 100 = 11..19 or v = 2 and f % 100 = 11..19
			if math.Mod(ops.N, 10) == 0 || isFloatInRange(math.Mod(ops.N, 100), 11, 19) || ops.V == 2 && (ops.F%100 >= 11 && ops.F%100 <= 19) {
				return Zero
			}

			// n % 10 = 1 and n % 100 != 11 or v = 2 and f % 10 = 1 and f % 100 != 11 or v != 2 and f % 10 = 1
			if math.Mod(ops.N, 10) == 1 && math.Mod(ops.N, 100) != 11 || ops.V == 2 && ops.F%10 == 1 && ops.F%100 != 11 || ops.V != 2 && ops.F%10 == 1 {
				return One
			}

			return Other
		},
	}
}

// [mo ro]
func newRuleSetMoRo() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 1 and v = 0
			if ops.I == 1 && ops.V == 0 {
				return One
			}

			// v != 0 or n = 0 or n != 1 and n % 100 = 1..19
			if ops.V != 0 || ops.N == 0 || ops.N != 1 && isFloatInRange(math.Mod(ops.N, 100), 1, 19) {
				return Few
			}

			return Other
		},
	}
}

// [pt]
func newRuleSetPt() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 0..1
			if ops.I >= 0 && ops.I <= 1 {
				return One
			}

			// e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5
			if ops.C == 0 && ops.I != 0 && ops.I%1000000 == 0 && ops.V == 0 || !(ops.C >= 0 && ops.C <= 5) {
				return Many
			}

			return Other
		},
	}
}

// [shi]
func newRuleSetShi() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 0 or n = 1
			if ops.I == 0 || ops.N == 1 {
				return One
			}

			// n = 2..10
			if isFloatInRange(ops.N, 2, 10) {
				return Few
			}

			return Other
		},
	}
}

// [be]
func newRuleSetBe() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n % 10 = 1 and n % 100 != 11
			if math.Mod(ops.N, 10) == 1 && math.Mod(ops.N, 100) != 11 {
				return One
			}

			// n % 10 = 2..4 and n % 100 != 12..14
			if isFloatInRange(math.Mod(ops.N, 10), 2, 4) && !isFloatInRange(math.Mod(ops.N, 100), 12, 14) {
				return Few
			}

			// n % 10 = 0 or n % 10 = 5..9 or n % 100 = 11..14
			if math.Mod(ops.N, 10) == 0 || isFloatInRange(math.Mod(ops.N, 10), 5, 9) || isFloatInRange(math.Mod(ops.N, 100), 11, 14) {
				return Many
			}

			return Other
		},
	}
}

// [cs sk]
func newRuleSetCsSk() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 1 and v = 0
			if ops.I == 1 && ops.V == 0 {
				return One
			}

			// i = 2..4 and v = 0
			if (ops.I >= 2 && ops.I <= 4) && ops.V == 0 {
				return Few
			}

			// v != 0
			if ops.V != 0 {
				return Many
			}

			return Other
		},
	}
}

// [dsb hsb]
func newRuleSetDsbHsb() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Few, Other},
		FormFunc: func(ops *Operands) Category {
			// v = 0 and i % 100 = 1 or f % 100 = 1
			if ops.V == 0 && ops.I%100 == 1 || ops.F%100 == 1 {
				return One
			}

			// v = 0 and i % 100 = 2 or f % 100 = 2
			if ops.V == 0 && ops.I%100 == 2 || ops.F%100 == 2 {
				return Two
			}

			// v = 0 and i % 100 = 3..4 or f % 100 = 3..4
			if ops.V == 0 && (ops.I%100 >= 3 && ops.I%100 <= 4) || (ops.F%100 >= 3 && ops.F%100 <= 4) {
				return Few
			}

			return Other
		},
	}
}

// [gd]
func newRuleSetGd() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Few, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 1,11
			if isFloatOneOf(ops.N, 1, 11) {
				return One
			}

			// n = 2,12
			if isFloatOneOf(ops.N, 2, 12) {
				return Two
			}

			// n = 3..10,13..19
			if isFloatInRange(ops.N, 3, 10, 13, 19) {
				return Few
			}

			return Other
		},
	}
}

// [lt]
func newRuleSetLt() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n % 10 = 1 and n % 100 != 11..19
			if math.Mod(ops.N, 10) == 1 && !isFloatInRange(math.Mod(ops.N, 100), 11, 19) {
				return One
			}

			// n % 10 = 2..9 and n % 100 != 11..19
			if isFloatInRange(math.Mod(ops.N, 10), 2, 9) && !isFloatInRange(math.Mod(ops.N, 100), 11, 19) {
				return Few
			}

			// f != 0
			if ops.F != 0 {
				return Many
			}

			return Other
		},
	}
}

// [pl]
func newRuleSetPl() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// i = 1 and v = 0
			if ops.I == 1 && ops.V == 0 {
				return One
			}

			// v = 0 and i % 10 = 2..4 and i % 100 != 12..14
			if ops.V == 0 && (ops.I%10 >= 2 && ops.I%10 <= 4) && !(ops.I%100 >= 12 && ops.I%100 <= 14) {
				return Few
			}

			// v = 0 and i != 1 and i % 10 = 0..1 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 12..14
			if ops.V == 0 && ops.I != 1 && (ops.I%10 >= 0 && ops.I%10 <= 1) || ops.V == 0 && (ops.I%10 >= 5 && ops.I%10 <= 9) || ops.V == 0 && (ops.I%100 >= 12 && ops.I%100 <= 14) {
				return Many
			}

			return Other
		},
	}
}

// [ru uk]
func newRuleSetRuUk() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// v = 0 and i % 10 = 1 and i % 100 != 11
			if ops.V == 0 && ops.I%10 == 1 && ops.I%100 != 11 {
				return One
			}

			// v = 0 and i % 10 = 2..4 and i % 100 != 12..14
			if ops.V == 0 && (ops.I%10 >= 2 && ops.I%10 <= 4) && !(ops.I%100 >= 12 && ops.I%100 <= 14) {
				return Few
			}

			// v = 0 and i % 10 = 0 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 11..14
			if ops.V == 0 && ops.I%10 == 0 || ops.V == 0 && (ops.I%10 >= 5 && ops.I%10 <= 9) || ops.V == 0 && (ops.I%100 >= 11 && ops.I%100 <= 14) {
				return Many
			}

			return Other
		},
	}
}

// [sl]
func newRuleSetSl() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Few, Other},
		FormFunc: func(ops *Operands) Category {
			// v = 0 and i % 100 = 1
			if ops.V == 0 && ops.I%100 == 1 {
				return One
			}

			// v = 0 and i % 100 = 2
			if ops.V == 0 && ops.I%100 == 2 {
				return Two
			}

			// v = 0 and i % 100 = 3..4 or v != 0
			if ops.V == 0 && (ops.I%100 >= 3 && ops.I%100 <= 4) || ops.V != 0 {
				return Few
			}

			return Other
		},
	}
}

// [br]
func newRuleSetBr() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n % 10 = 1 and n % 100 != 11,71,91
			if math.Mod(ops.N, 10) == 1 && !isFloatOneOf(math.Mod(ops.N, 100), 11, 71, 91) {
				return One
			}

			// n % 10 = 2 and n % 100 != 12,72,92
			if math.Mod(ops.N, 10) == 2 && !isFloatOneOf(math.Mod(ops.N, 100), 12, 72, 92) {
				return Two
			}

			// n % 10 = 3..4,9 and n % 100 != 10..19,70..79,90..99
			if (isFloatInRange(math.Mod(ops.N, 10), 3, 4) || math.Mod(ops.N, 10) == 9) && !isFloatInRange(math.Mod(ops.N, 100), 10, 19, 70, 79, 90, 99) {
				return Few
			}

			// n != 0 and n % 1000000 = 0
			if ops.N != 0 && math.Mod(ops.N, 1000000) == 0 {
				return Many
			}

			return Other
		},
	}
}

// [ga]
func newRuleSetGa() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 1
			if ops.N == 1 {
				return One
			}

			// n = 2
			if ops.N == 2 {
				return Two
			}

			// n = 3..6
			if isFloatInRange(ops.N, 3, 6) {
				return Few
			}

			// n = 7..10
			if isFloatInRange(ops.N, 7, 10) {
				return Many
			}

			return Other
		},
	}
}

// [gv]
func newRuleSetGv() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// v = 0 and i % 10 = 1
			if ops.V == 0 && ops.I%10 == 1 {
				return One
			}

			// v = 0 and i % 10 = 2
			if ops.V == 0 && ops.I%10 == 2 {
				return Two
			}

			// v = 0 and i % 100 = 0,20,40,60,80
			if ops.V == 0 && slices.Contains([]int64{0, 20, 40, 60, 80}, ops.I%100) {
				return Few
			}

			// v != 0
			if ops.V != 0 {
				return Many
			}

			return Other
		},
	}
}

// [mt]
func newRuleSetMt() *RuleSet {
	return &RuleSet{
		Categories: []Category{One, Two, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 1
			if ops.N == 1 {
				return One
			}

			// n = 2
			if ops.N == 2 {
				return Two
			}

			// n = 0 or n % 100 = 3..10
			if ops.N == 0 || isFloatInRange(math.Mod(ops.N, 100), 3, 10) {
				return Few
			}

			// n % 100 = 11..19
			if isFloatInRange(math.Mod(ops.N, 100), 11, 19) {
				return Many
			}

			return Other
		},
	}
}

// [ar ars]
func newRuleSetArArs() *RuleSet {
	return &RuleSet{
		Categories: []Category{Zero, One, Two, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0
			if ops.N == 0 {
				return Zero
			}

			// n = 1
			if ops.N == 1 {
				return One
			}

			// n = 2
			if ops.N == 2 {
				return Two
			}

			// n % 100 = 3..10
			if isFloatInRange(math.Mod(ops.N, 100), 3, 10) {
				return Few
			}

			// n % 100 = 11..99
			if isFloatInRange(math.Mod(ops.N, 100), 11, 99) {
				return Many
			}

			return Other
		},
	}
}

// [cy]
func newRuleSetCy() *RuleSet {
	return &RuleSet{
		Categories: []Category{Zero, One, Two, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0
			if ops.N == 0 {
				return Zero
			}

			// n = 1
			if ops.N == 1 {
				return One
			}

			// n = 2
			if ops.N == 2 {
				return Two
			}

			// n = 3
			if ops.N == 3 {
				return Few
			}

			// n = 6
			if ops.N == 6 {
				return Many
			}

			return Other
		},
	}
}

// [kw]
func newRuleSetKw() *RuleSet {
	return &RuleSet{
		Categories: []Category{Zero, One, Two, Few, Many, Other},
		FormFunc: func(ops *Operands) Category {
			// n = 0
			if ops.N == 0 {
				return Zero
			}

			// n = 1
			if ops.N == 1 {
				return One
			}

			// n % 100 = 2,22,42,62,82 or n % 1000 = 0 and n % 100000 = 1000..20000,40000,60000,80000 or n != 0 and n % 1000000 = 100000
			if isFloatOneOf(math.Mod(ops.N, 100), 2, 22, 42, 62, 82) || math.Mod(ops.N, 1000) == 0 && (isFloatInRange(math.Mod(ops.N, 100000), 1000, 20000) || isFloatOneOf(math.Mod(ops.N, 100000), 40000, 60000, 80000)) || ops.N != 0 && math.Mod(ops.N, 1000000) == 100000 {
				return Two
			}

			// n % 100 = 3,23,43,63,83
			if isFloatOneOf(math.Mod(ops.N, 100), 3, 23, 43, 63, 83) {
				return Few
			}

			// n != 1 and n % 100 = 1,21,41,61,81
			if ops.N != 1 && isFloatOneOf(math.Mod(ops.N, 100), 1, 21, 41, 61, 81) {
				return Many
			}

			return Other
		},
	}
}
