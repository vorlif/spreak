// This file is generated by cldrplural/generator/generate.sh; DO NOT EDIT
package cldrplural

import (
	"testing"

	"github.com/stretchr/testify/assert"

	ast2 "github.com/vorlif/spreak/catalog/cldrplural/ast"
)

func TestEvaluateBmBoDzHnjIdIgIiJaJboJvJwKdeKeaKmKoLktLoMsMyNqoOsaSahSesSgSuThToTpiUndViWoYoYueZh(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse(" @integer 0~15, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "100", "1000", "10000", "100000", "1000000", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateAfAnAsaAzBalBemBezBgBrxCeCggChrCkbDvEeElEoEuFoFurGswHaHawHuJgoJmcKaKajKcgKkKkjKlKsKsbKuKyLbLgMasMgoMlMnMrNahNbNdNeNnNnhNoNrNyNynOmOrOsPapPsRmRofRwkSaqSdSdhSehSnSoSqSsSsyStSyrTaTeTeoTigTkTnTrTsUgUzVeVoVunWaeXhXog(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "100", "1000", "10000", "100000", "1000000", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateAkBhoGuwLnMgNsoPaTiWa(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0..1 @integer 0, 1 @decimal 0.0, 1.0, 0.00, 1.00, 0.000, 1.000, 0.0000, 1.0000")

	for _, sample := range []string{"0", "1", "0.0", "1.0", "0.00", "1.00", "0.000", "1.000", "0.0000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1000000", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateAmAsBnDoiFaGuHiKnPcmZu(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04")

	for _, sample := range []string{"0", "1", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "0.00", "0.01", "0.02", "0.03", "0.04"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~2.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1000000", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "1.9", "2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateAstCaDeEnEtFiFyGlIaIoLijNlScScnSvSwUrYi(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 1 and v = 0 @integer 1")

	for _, sample := range []string{"1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "100", "1000", "10000", "100000", "1000000", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateCebFilTl(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("v = 0 and i = 1,2,3 or v = 0 and i % 10 != 4,6,9 or v != 0 and f % 10 != 4,6,9 @integer 0~3, 5, 7, 8, 10~13, 15, 17, 18, 20, 21, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.3, 0.5, 0.7, 0.8, 1.0~1.3, 1.5, 1.7, 1.8, 2.0, 2.1, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "1", "2", "3", "5", "7", "8", "10", "11", "12", "13", "15", "17", "18", "20", "21", "100", "1000", "10000", "100000", "1000000", "0.0", "0.1", "0.2", "0.3", "0.5", "0.7", "0.8", "1.0", "1.1", "1.2", "1.3", "1.5", "1.7", "1.8", "2.0", "2.1", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 4, 6, 9, 14, 16, 19, 24, 26, 104, 1004, … @decimal 0.4, 0.6, 0.9, 1.4, 1.6, 1.9, 2.4, 2.6, 10.4, 100.4, 1000.4, …")

	for _, sample := range []string{"4", "6", "9", "14", "16", "19", "24", "26", "104", "1004", "0.4", "0.6", "0.9", "1.4", "1.6", "1.9", "2.4", "2.6", "10.4", "100.4", "1000.4"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateDa(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 1 or t != 0 and i = 0,1 @integer 1 @decimal 0.1~1.6")

	for _, sample := range []string{"1", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 2.0~3.4, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "100", "1000", "10000", "100000", "1000000", "0.0", "2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "3.0", "3.1", "3.2", "3.3", "3.4", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateFfHyKab(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 0,1 @integer 0, 1 @decimal 0.0~1.5")

	for _, sample := range []string{"0", "1", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1000000", "2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "3.0", "3.1", "3.2", "3.3", "3.4", "3.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateIs(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("t = 0 and i % 10 = 1 and i % 100 != 11 or t != 0 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1~1.6, 10.1, 100.1, 1000.1, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "71", "81", "101", "1001", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "10.1", "100.1", "1000.1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "100", "1000", "10000", "100000", "1000000", "0.0", "2.0", "3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateMk(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "71", "81", "101", "1001", "0.1", "1.1", "2.1", "3.1", "4.1", "5.1", "6.1", "7.1", "10.1", "100.1", "1000.1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 2~16, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.2~1.0, 1.2~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "100", "1000", "10000", "100000", "1000000", "0.0", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateSi(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0,1 or i = 0 and f = 1 @integer 0, 1 @decimal 0.0, 0.1, 1.0, 0.00, 0.01, 1.00, 0.000, 0.001, 1.000, 0.0000, 0.0001, 1.0000")

	for _, sample := range []string{"0", "1", "0.0", "0.1", "1.0", "0.00", "0.01", "1.00", "0.000", "0.001", "1.000", "0.0000", "0.0001", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.2~0.9, 1.1~1.8, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1000000", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateTzm(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0..1 or n = 11..99 @integer 0, 1, 11~24 @decimal 0.0, 1.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0")

	for _, sample := range []string{"0", "1", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "0.0", "1.0", "11.0", "12.0", "13.0", "14.0", "15.0", "16.0", "17.0", "18.0", "19.0", "20.0", "21.0", "22.0", "23.0", "24.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~10, 100~106, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "100", "101", "102", "103", "104", "105", "106", "1000", "10000", "100000", "1000000", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateBsHrShSr(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("v = 0 and i % 10 = 1 and i % 100 != 11 or f % 10 = 1 and f % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "71", "81", "101", "1001", "0.1", "1.1", "2.1", "3.1", "4.1", "5.1", "6.1", "7.1", "10.1", "100.1", "1000.1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 10 = 2..4 and i % 100 != 12..14 or f % 10 = 2..4 and f % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, … @decimal 0.2~0.4, 1.2~1.4, 2.2~2.4, 3.2~3.4, 4.2~4.4, 5.2, 10.2, 100.2, 1000.2, …")

	for _, sample := range []string{"2", "3", "4", "22", "23", "24", "32", "33", "34", "42", "43", "44", "52", "53", "54", "62", "102", "1002", "0.2", "0.3", "0.4", "1.2", "1.3", "1.4", "2.2", "2.3", "2.4", "3.2", "3.3", "3.4", "4.2", "4.3", "4.4", "5.2", "10.2", "100.2", "1000.2"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1000", "10000", "100000", "1000000", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.5", "1.6", "1.7", "1.8", "1.9", "2.0", "2.5", "2.6", "2.7", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateEs(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5 @integer 1000000, 1c6, 2c6, 3c6, 4c6, 5c6, 6c6, … @decimal 1.0000001c6, 1.1c6, 2.0000001c6, 2.1c6, 3.0000001c6, 3.1c6, …")

	for _, sample := range []string{"1000000", "1c6", "2c6", "3c6", "4c6", "5c6", "6c6", "1.0000001c6", "1.1c6", "2.0000001c6", "2.1c6", "3.0000001c6", "3.1c6"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 2~16, 100, 1000, 10000, 100000, 1c3, 2c3, 3c3, 4c3, 5c3, 6c3, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 1.0001c3, 1.1c3, 2.0001c3, 2.1c3, 3.0001c3, 3.1c3, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "100", "1000", "10000", "100000", "1c3", "2c3", "3c3", "4c3", "5c3", "6c3", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0", "1.0001c3", "1.1c3", "2.0001c3", "2.1c3", "3.0001c3", "3.1c3"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateFr(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 0,1 @integer 0, 1 @decimal 0.0~1.5")

	for _, sample := range []string{"0", "1", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5 @integer 1000000, 1c6, 2c6, 3c6, 4c6, 5c6, 6c6, … @decimal 1.0000001c6, 1.1c6, 2.0000001c6, 2.1c6, 3.0000001c6, 3.1c6, …")

	for _, sample := range []string{"1000000", "1c6", "2c6", "3c6", "4c6", "5c6", "6c6", "1.0000001c6", "1.1c6", "2.0000001c6", "2.1c6", "3.0000001c6", "3.1c6"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1c3, 2c3, 3c3, 4c3, 5c3, 6c3, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 1.0001c3, 1.1c3, 2.0001c3, 2.1c3, 3.0001c3, 3.1c3, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1c3", "2c3", "3c3", "4c3", "5c3", "6c3", "2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "3.0", "3.1", "3.2", "3.3", "3.4", "3.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0", "1.0001c3", "1.1c3", "2.0001c3", "2.1c3", "3.0001c3", "3.1c3"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateItPt_PT(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 1 and v = 0 @integer 1")

	for _, sample := range []string{"1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5 @integer 1000000, 1c6, 2c6, 3c6, 4c6, 5c6, 6c6, … @decimal 1.0000001c6, 1.1c6, 2.0000001c6, 2.1c6, 3.0000001c6, 3.1c6, …")

	for _, sample := range []string{"1000000", "1c6", "2c6", "3c6", "4c6", "5c6", "6c6", "1.0000001c6", "1.1c6", "2.0000001c6", "2.1c6", "3.0000001c6", "3.1c6"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 2~16, 100, 1000, 10000, 100000, 1c3, 2c3, 3c3, 4c3, 5c3, 6c3, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 1.0001c3, 1.1c3, 2.0001c3, 2.1c3, 3.0001c3, 3.1c3, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "100", "1000", "10000", "100000", "1c3", "2c3", "3c3", "4c3", "5c3", "6c3", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0", "1.0001c3", "1.1c3", "2.0001c3", "2.1c3", "3.0001c3", "3.1c3"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateIuNaqSatSeSmaSmiSmjSmnSms(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000")

	for _, sample := range []string{"2", "2.0", "2.00", "2.000", "2.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 3~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1000000", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateKsh(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000")

	for _, sample := range []string{"0", "0.0", "0.00", "0.000", "0.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1000000", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateLag(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000")

	for _, sample := range []string{"0", "0.0", "0.00", "0.000", "0.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("i = 0,1 and n != 0 @integer 1 @decimal 0.1~1.6")

	for _, sample := range []string{"1", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1000000, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1000000", "2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "3.0", "3.1", "3.2", "3.3", "3.4", "3.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateLvPrg(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n % 10 = 0 or n % 100 = 11..19 or v = 2 and f % 100 = 11..19 @integer 0, 10~20, 30, 40, 50, 60, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "30", "40", "50", "60", "100", "1000", "10000", "100000", "1000000", "0.0", "10.0", "11.0", "12.0", "13.0", "14.0", "15.0", "16.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 10 = 1 and n % 100 != 11 or v = 2 and f % 10 = 1 and f % 100 != 11 or v != 2 and f % 10 = 1 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 0.1, 1.0, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "71", "81", "101", "1001", "0.1", "1.0", "1.1", "2.1", "3.1", "4.1", "5.1", "6.1", "7.1", "10.1", "100.1", "1000.1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~9, 22~29, 102, 1002, … @decimal 0.2~0.9, 1.2~1.9, 10.2, 100.2, 1000.2, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "22", "23", "24", "25", "26", "27", "28", "29", "102", "1002", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "1.9", "10.2", "100.2", "1000.2"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateMoRo(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 1 and v = 0 @integer 1")

	for _, sample := range []string{"1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v != 0 or n = 0 or n % 100 = 2..19 @integer 0, 2~16, 102, 1002, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "102", "1002", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 20~35, 100, 1000, 10000, 100000, 1000000, …")

	for _, sample := range []string{"20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "100", "1000", "10000", "100000", "1000000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluatePt(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 0..1 @integer 0, 1 @decimal 0.0~1.5")

	for _, sample := range []string{"0", "1", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("e = 0 and i != 0 and i % 1000000 = 0 and v = 0 or e != 0..5 @integer 1000000, 1c6, 2c6, 3c6, 4c6, 5c6, 6c6, … @decimal 1.0000001c6, 1.1c6, 2.0000001c6, 2.1c6, 3.0000001c6, 3.1c6, …")

	for _, sample := range []string{"1000000", "1c6", "2c6", "3c6", "4c6", "5c6", "6c6", "1.0000001c6", "1.1c6", "2.0000001c6", "2.1c6", "3.0000001c6", "3.1c6"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 2~17, 100, 1000, 10000, 100000, 1c3, 2c3, 3c3, 4c3, 5c3, 6c3, … @decimal 2.0~3.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, 1.0001c3, 1.1c3, 2.0001c3, 2.1c3, 3.0001c3, 3.1c3, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "100", "1000", "10000", "100000", "1c3", "2c3", "3c3", "4c3", "5c3", "6c3", "2.0", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "2.8", "2.9", "3.0", "3.1", "3.2", "3.3", "3.4", "3.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0", "1.0001c3", "1.1c3", "2.0001c3", "2.1c3", "3.0001c3", "3.1c3"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateShi(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 0 or n = 1 @integer 0, 1 @decimal 0.0~1.0, 0.00~0.04")

	for _, sample := range []string{"0", "1", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "0.00", "0.01", "0.02", "0.03", "0.04"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 2..10 @integer 2~10 @decimal 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 2.00, 3.00, 4.00, 5.00, 6.00, 7.00, 8.00")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "10", "2.0", "3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0", "2.00", "3.00", "4.00", "5.00", "6.00", "7.00", "8.00"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 11~26, 100, 1000, 10000, 100000, 1000000, … @decimal 1.1~1.9, 2.1~2.7, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "100", "1000", "10000", "100000", "1000000", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "1.8", "1.9", "2.1", "2.2", "2.3", "2.4", "2.5", "2.6", "2.7", "10.1", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateBe(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n % 10 = 1 and n % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 1.0, 21.0, 31.0, 41.0, 51.0, 61.0, 71.0, 81.0, 101.0, 1001.0, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "71", "81", "101", "1001", "1.0", "21.0", "31.0", "41.0", "51.0", "61.0", "71.0", "81.0", "101.0", "1001.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 10 = 2..4 and n % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, … @decimal 2.0, 3.0, 4.0, 22.0, 23.0, 24.0, 32.0, 33.0, 102.0, 1002.0, …")

	for _, sample := range []string{"2", "3", "4", "22", "23", "24", "32", "33", "34", "42", "43", "44", "52", "53", "54", "62", "102", "1002", "2.0", "3.0", "4.0", "22.0", "23.0", "24.0", "32.0", "33.0", "102.0", "1002.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 10 = 0 or n % 10 = 5..9 or n % 100 = 11..14 @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1000", "10000", "100000", "1000000", "0.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0", "11.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("   @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.1, 1000.1, …")

	for _, sample := range []string{"0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.1", "100.1", "1000.1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateCsSk(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 1 and v = 0 @integer 1")

	for _, sample := range []string{"1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("i = 2..4 and v = 0 @integer 2~4")

	for _, sample := range []string{"2", "3", "4"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v != 0   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1000", "10000", "100000", "1000000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateDsbHsb(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("v = 0 and i % 100 = 1 or f % 100 = 1 @integer 1, 101, 201, 301, 401, 501, 601, 701, 1001, … @decimal 0.1, 1.1, 2.1, 3.1, 4.1, 5.1, 6.1, 7.1, 10.1, 100.1, 1000.1, …")

	for _, sample := range []string{"1", "101", "201", "301", "401", "501", "601", "701", "1001", "0.1", "1.1", "2.1", "3.1", "4.1", "5.1", "6.1", "7.1", "10.1", "100.1", "1000.1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 100 = 2 or f % 100 = 2 @integer 2, 102, 202, 302, 402, 502, 602, 702, 1002, … @decimal 0.2, 1.2, 2.2, 3.2, 4.2, 5.2, 6.2, 7.2, 10.2, 100.2, 1000.2, …")

	for _, sample := range []string{"2", "102", "202", "302", "402", "502", "602", "702", "1002", "0.2", "1.2", "2.2", "3.2", "4.2", "5.2", "6.2", "7.2", "10.2", "100.2", "1000.2"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 100 = 3..4 or f % 100 = 3..4 @integer 3, 4, 103, 104, 203, 204, 303, 304, 403, 404, 503, 504, 603, 604, 703, 704, 1003, … @decimal 0.3, 0.4, 1.3, 1.4, 2.3, 2.4, 3.3, 3.4, 4.3, 4.4, 5.3, 5.4, 6.3, 6.4, 7.3, 7.4, 10.3, 100.3, 1000.3, …")

	for _, sample := range []string{"3", "4", "103", "104", "203", "204", "303", "304", "403", "404", "503", "504", "603", "604", "703", "704", "1003", "0.3", "0.4", "1.3", "1.4", "2.3", "2.4", "3.3", "3.4", "4.3", "4.4", "5.3", "5.4", "6.3", "6.4", "7.3", "7.4", "10.3", "100.3", "1000.3"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 0.5~1.0, 1.5~2.0, 2.5~2.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1000", "10000", "100000", "1000000", "0.0", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.5", "1.6", "1.7", "1.8", "1.9", "2.0", "2.5", "2.6", "2.7", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateGd(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 1,11 @integer 1, 11 @decimal 1.0, 11.0, 1.00, 11.00, 1.000, 11.000, 1.0000")

	for _, sample := range []string{"1", "11", "1.0", "11.0", "1.00", "11.00", "1.000", "11.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 2,12 @integer 2, 12 @decimal 2.0, 12.0, 2.00, 12.00, 2.000, 12.000, 2.0000")

	for _, sample := range []string{"2", "12", "2.0", "12.0", "2.00", "12.00", "2.000", "12.000", "2.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 3..10,13..19 @integer 3~10, 13~19 @decimal 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 3.00")

	for _, sample := range []string{"3", "4", "5", "6", "7", "8", "9", "10", "13", "14", "15", "16", "17", "18", "19", "3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0", "13.0", "14.0", "15.0", "16.0", "17.0", "18.0", "19.0", "3.00"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 20~34, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "100", "1000", "10000", "100000", "1000000", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "10.1", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateHe(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 1 and v = 0 @integer 1")

	for _, sample := range []string{"1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("i = 2 and v = 0 @integer 2")

	for _, sample := range []string{"2"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and n != 0..10 and n % 10 = 0 @integer 20, 30, 40, 50, 60, 70, 80, 90, 100, 1000, 10000, 100000, 1000000, …")

	for _, sample := range []string{"20", "30", "40", "50", "60", "70", "80", "90", "100", "1000", "10000", "100000", "1000000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 3~17, 101, 1001, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "101", "1001", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateLt(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n % 10 = 1 and n % 100 != 11..19 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, … @decimal 1.0, 21.0, 31.0, 41.0, 51.0, 61.0, 71.0, 81.0, 101.0, 1001.0, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "71", "81", "101", "1001", "1.0", "21.0", "31.0", "41.0", "51.0", "61.0", "71.0", "81.0", "101.0", "1001.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 10 = 2..9 and n % 100 != 11..19 @integer 2~9, 22~29, 102, 1002, … @decimal 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 22.0, 102.0, 1002.0, …")

	for _, sample := range []string{"2", "3", "4", "5", "6", "7", "8", "9", "22", "23", "24", "25", "26", "27", "28", "29", "102", "1002", "2.0", "3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "22.0", "102.0", "1002.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("f != 0   @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.1, 1000.1, …")

	for _, sample := range []string{"0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.1", "100.1", "1000.1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 10~20, 30, 40, 50, 60, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0, 10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "30", "40", "50", "60", "100", "1000", "10000", "100000", "1000000", "0.0", "10.0", "11.0", "12.0", "13.0", "14.0", "15.0", "16.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateMt(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 0 or n % 100 = 2..10 @integer 0, 2~10, 102~107, 1002, … @decimal 0.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 10.0, 102.0, 1002.0, …")

	for _, sample := range []string{"0", "2", "3", "4", "5", "6", "7", "8", "9", "10", "102", "103", "104", "105", "106", "107", "1002", "0.0", "2.0", "3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "10.0", "102.0", "1002.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 100 = 11..19 @integer 11~19, 111~117, 1011, … @decimal 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 111.0, 1011.0, …")

	for _, sample := range []string{"11", "12", "13", "14", "15", "16", "17", "18", "19", "111", "112", "113", "114", "115", "116", "117", "1011", "11.0", "12.0", "13.0", "14.0", "15.0", "16.0", "17.0", "18.0", "111.0", "1011.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 20~35, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "30", "31", "32", "33", "34", "35", "100", "1000", "10000", "100000", "1000000", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.1", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluatePl(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("i = 1 and v = 0 @integer 1")

	for _, sample := range []string{"1"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 10 = 2..4 and i % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, …")

	for _, sample := range []string{"2", "3", "4", "22", "23", "24", "32", "33", "34", "42", "43", "44", "52", "53", "54", "62", "102", "1002"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i != 1 and i % 10 = 0..1 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 12..14 @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1000", "10000", "100000", "1000000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateRuUk(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("v = 0 and i % 10 = 1 and i % 100 != 11 @integer 1, 21, 31, 41, 51, 61, 71, 81, 101, 1001, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "71", "81", "101", "1001"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 10 = 2..4 and i % 100 != 12..14 @integer 2~4, 22~24, 32~34, 42~44, 52~54, 62, 102, 1002, …")

	for _, sample := range []string{"2", "3", "4", "22", "23", "24", "32", "33", "34", "42", "43", "44", "52", "53", "54", "62", "102", "1002"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 10 = 0 or v = 0 and i % 10 = 5..9 or v = 0 and i % 100 = 11..14 @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1000", "10000", "100000", "1000000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateSl(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("v = 0 and i % 100 = 1 @integer 1, 101, 201, 301, 401, 501, 601, 701, 1001, …")

	for _, sample := range []string{"1", "101", "201", "301", "401", "501", "601", "701", "1001"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 100 = 2 @integer 2, 102, 202, 302, 402, 502, 602, 702, 1002, …")

	for _, sample := range []string{"2", "102", "202", "302", "402", "502", "602", "702", "1002"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 100 = 3..4 or v != 0 @integer 3, 4, 103, 104, 203, 204, 303, 304, 403, 404, 503, 504, 603, 604, 703, 704, 1003, … @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"3", "4", "103", "104", "203", "204", "303", "304", "403", "404", "503", "504", "603", "604", "703", "704", "1003", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 5~19, 100, 1000, 10000, 100000, 1000000, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1000", "10000", "100000", "1000000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateBr(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n % 10 = 1 and n % 100 != 11,71,91 @integer 1, 21, 31, 41, 51, 61, 81, 101, 1001, … @decimal 1.0, 21.0, 31.0, 41.0, 51.0, 61.0, 81.0, 101.0, 1001.0, …")

	for _, sample := range []string{"1", "21", "31", "41", "51", "61", "81", "101", "1001", "1.0", "21.0", "31.0", "41.0", "51.0", "61.0", "81.0", "101.0", "1001.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 10 = 2 and n % 100 != 12,72,92 @integer 2, 22, 32, 42, 52, 62, 82, 102, 1002, … @decimal 2.0, 22.0, 32.0, 42.0, 52.0, 62.0, 82.0, 102.0, 1002.0, …")

	for _, sample := range []string{"2", "22", "32", "42", "52", "62", "82", "102", "1002", "2.0", "22.0", "32.0", "42.0", "52.0", "62.0", "82.0", "102.0", "1002.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 10 = 3..4,9 and n % 100 != 10..19,70..79,90..99 @integer 3, 4, 9, 23, 24, 29, 33, 34, 39, 43, 44, 49, 103, 1003, … @decimal 3.0, 4.0, 9.0, 23.0, 24.0, 29.0, 33.0, 34.0, 103.0, 1003.0, …")

	for _, sample := range []string{"3", "4", "9", "23", "24", "29", "33", "34", "39", "43", "44", "49", "103", "1003", "3.0", "4.0", "9.0", "23.0", "24.0", "29.0", "33.0", "34.0", "103.0", "1003.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n != 0 and n % 1000000 = 0 @integer 1000000, … @decimal 1000000.0, 1000000.00, 1000000.000, 1000000.0000, …")

	for _, sample := range []string{"1000000", "1000000.0", "1000000.00", "1000000.000", "1000000.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 5~8, 10~20, 100, 1000, 10000, 100000, … @decimal 0.0~0.9, 1.1~1.6, 10.0, 100.0, 1000.0, 10000.0, 100000.0, …")

	for _, sample := range []string{"0", "5", "6", "7", "8", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "100", "1000", "10000", "100000", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "10.0", "100.0", "1000.0", "10000.0", "100000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateGa(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000")

	for _, sample := range []string{"2", "2.0", "2.00", "2.000", "2.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 3..6 @integer 3~6 @decimal 3.0, 4.0, 5.0, 6.0, 3.00, 4.00, 5.00, 6.00, 3.000, 4.000, 5.000, 6.000, 3.0000, 4.0000, 5.0000, 6.0000")

	for _, sample := range []string{"3", "4", "5", "6", "3.0", "4.0", "5.0", "6.0", "3.00", "4.00", "5.00", "6.00", "3.000", "4.000", "5.000", "6.000", "3.0000", "4.0000", "5.0000", "6.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 7..10 @integer 7~10 @decimal 7.0, 8.0, 9.0, 10.0, 7.00, 8.00, 9.00, 10.00, 7.000, 8.000, 9.000, 10.000, 7.0000, 8.0000, 9.0000, 10.0000")

	for _, sample := range []string{"7", "8", "9", "10", "7.0", "8.0", "9.0", "10.0", "7.00", "8.00", "9.00", "10.00", "7.000", "8.000", "9.000", "10.000", "7.0000", "8.0000", "9.0000", "10.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 0, 11~25, 100, 1000, 10000, 100000, 1000000, … @decimal 0.0~0.9, 1.1~1.6, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "100", "1000", "10000", "100000", "1000000", "0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "10.1", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateGv(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("v = 0 and i % 10 = 1 @integer 1, 11, 21, 31, 41, 51, 61, 71, 101, 1001, …")

	for _, sample := range []string{"1", "11", "21", "31", "41", "51", "61", "71", "101", "1001"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 10 = 2 @integer 2, 12, 22, 32, 42, 52, 62, 72, 102, 1002, …")

	for _, sample := range []string{"2", "12", "22", "32", "42", "52", "62", "72", "102", "1002"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v = 0 and i % 100 = 0,20,40,60,80 @integer 0, 20, 40, 60, 80, 100, 120, 140, 1000, 10000, 100000, 1000000, …")

	for _, sample := range []string{"0", "20", "40", "60", "80", "100", "120", "140", "1000", "10000", "100000", "1000000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("v != 0   @decimal 0.0~1.5, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"0.0", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 3~10, 13~19, 23, 103, 1003, …")

	for _, sample := range []string{"3", "4", "5", "6", "7", "8", "9", "10", "13", "14", "15", "16", "17", "18", "19", "23", "103", "1003"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateArArs(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000")

	for _, sample := range []string{"0", "0.0", "0.00", "0.000", "0.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000")

	for _, sample := range []string{"2", "2.0", "2.00", "2.000", "2.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 100 = 3..10 @integer 3~10, 103~110, 1003, … @decimal 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 103.0, 1003.0, …")

	for _, sample := range []string{"3", "4", "5", "6", "7", "8", "9", "10", "103", "104", "105", "106", "107", "108", "109", "110", "1003", "3.0", "4.0", "5.0", "6.0", "7.0", "8.0", "9.0", "10.0", "103.0", "1003.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 100 = 11..99 @integer 11~26, 111, 1011, … @decimal 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 111.0, 1011.0, …")

	for _, sample := range []string{"11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "21", "22", "23", "24", "25", "26", "111", "1011", "11.0", "12.0", "13.0", "14.0", "15.0", "16.0", "17.0", "18.0", "111.0", "1011.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 100~102, 200~202, 300~302, 400~402, 500~502, 600, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.1, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"100", "101", "102", "200", "201", "202", "300", "301", "302", "400", "401", "402", "500", "501", "502", "600", "1000", "10000", "100000", "1000000", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.1", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateCy(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000")

	for _, sample := range []string{"0", "0.0", "0.00", "0.000", "0.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 2 @integer 2 @decimal 2.0, 2.00, 2.000, 2.0000")

	for _, sample := range []string{"2", "2.0", "2.00", "2.000", "2.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 3 @integer 3 @decimal 3.0, 3.00, 3.000, 3.0000")

	for _, sample := range []string{"3", "3.0", "3.00", "3.000", "3.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 6 @integer 6 @decimal 6.0, 6.00, 6.000, 6.0000")

	for _, sample := range []string{"6", "6.0", "6.00", "6.000", "6.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 4, 5, 7~20, 100, 1000, 10000, 100000, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.0, 10000.0, 100000.0, 1000000.0, …")

	for _, sample := range []string{"4", "5", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "20", "100", "1000", "10000", "100000", "1000000", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.0", "100.0", "1000.0", "10000.0", "100000.0", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}

func TestEvaluateKw(t *testing.T) {
	var rule *ast2.Rule

	rule = ast2.MustParse("n = 0 @integer 0 @decimal 0.0, 0.00, 0.000, 0.0000")

	for _, sample := range []string{"0", "0.0", "0.00", "0.000", "0.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n = 1 @integer 1 @decimal 1.0, 1.00, 1.000, 1.0000")

	for _, sample := range []string{"1", "1.0", "1.00", "1.000", "1.0000"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 100 = 2,22,42,62,82 or n % 1000 = 0 and n % 100000 = 1000..20000,40000,60000,80000 or n != 0 and n % 1000000 = 100000 @integer 2, 22, 42, 62, 82, 102, 122, 142, 1000, 10000, 100000, … @decimal 2.0, 22.0, 42.0, 62.0, 82.0, 102.0, 122.0, 142.0, 1000.0, 10000.0, 100000.0, …")

	for _, sample := range []string{"2", "22", "42", "62", "82", "102", "122", "142", "1000", "10000", "100000", "2.0", "22.0", "42.0", "62.0", "82.0", "102.0", "122.0", "142.0", "1000.0", "10000.0", "100000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n % 100 = 3,23,43,63,83 @integer 3, 23, 43, 63, 83, 103, 123, 143, 1003, … @decimal 3.0, 23.0, 43.0, 63.0, 83.0, 103.0, 123.0, 143.0, 1003.0, …")

	for _, sample := range []string{"3", "23", "43", "63", "83", "103", "123", "143", "1003", "3.0", "23.0", "43.0", "63.0", "83.0", "103.0", "123.0", "143.0", "1003.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse("n != 1 and n % 100 = 1,21,41,61,81 @integer 21, 41, 61, 81, 101, 121, 141, 161, 1001, … @decimal 21.0, 41.0, 61.0, 81.0, 101.0, 121.0, 141.0, 161.0, 1001.0, …")

	for _, sample := range []string{"21", "41", "61", "81", "101", "121", "141", "161", "1001", "21.0", "41.0", "61.0", "81.0", "101.0", "121.0", "141.0", "161.0", "1001.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

	rule = ast2.MustParse(" @integer 4~19, 100, 1004, 1000000, … @decimal 0.1~0.9, 1.1~1.7, 10.0, 100.0, 1000.1, 1000000.0, …")

	for _, sample := range []string{"4", "5", "6", "7", "8", "9", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "100", "1004", "1000000", "0.1", "0.2", "0.3", "0.4", "0.5", "0.6", "0.7", "0.8", "0.9", "1.1", "1.2", "1.3", "1.4", "1.5", "1.6", "1.7", "10.0", "100.0", "1000.1", "1000000.0"} {
		op := MustNewOperands(sample)
		assert.True(t, evaluate(rule, op), sample)
	}

}
